package cli

import (
	"context"

	"github.com/dl-alexandre/gdrv/internal/api"
	"github.com/dl-alexandre/gdrv/internal/auth"
	"github.com/dl-alexandre/gdrv/internal/export"
	"github.com/dl-alexandre/gdrv/internal/files"
	"github.com/dl-alexandre/gdrv/internal/revisions"
	"github.com/dl-alexandre/gdrv/internal/types"
	"github.com/dl-alexandre/gdrv/internal/utils"
)

type FilesCmd struct {
	List          FilesListCmd          `cmd:"" help:"List files"`
	Get           FilesGetCmd           `cmd:"" help:"Get file metadata"`
	Upload        FilesUploadCmd        `cmd:"" help:"Upload a file"`
	Download      FilesDownloadCmd      `cmd:"" help:"Download a file"`
	Delete        FilesDeleteCmd        `cmd:"" help:"Delete a file"`
	Copy          FilesCopyCmd          `cmd:"" help:"Copy a file"`
	Move          FilesMoveCmd          `cmd:"" help:"Move a file"`
	Trash         FilesTrashCmd         `cmd:"" help:"Move file to trash"`
	Restore       FilesRestoreCmd       `cmd:"" help:"Restore file from trash"`
	Revisions     FilesRevisionsCmd     `cmd:"" help:"List file revisions"`
	ListTrashed   FilesListTrashedCmd   `cmd:"list-trashed" help:"List trashed files"`
	ExportFormats FilesExportFormatsCmd `cmd:"export-formats" help:"Show available export formats for a file"`
}

type FilesListCmd struct {
	Parent         string `help:"Parent folder ID" name:"parent"`
	Query          string `help:"Search query" name:"query"`
	Limit          int    `help:"Maximum files to return per page" default:"100" name:"limit"`
	PageToken      string `help:"Page token for pagination" name:"page-token"`
	OrderBy        string `help:"Sort order" name:"order-by"`
	IncludeTrashed bool   `help:"Include trashed files" name:"include-trashed"`
	Fields         string `help:"Fields to return" name:"fields"`
	Paginate       bool   `help:"Automatically fetch all pages" name:"paginate"`
}

type FilesGetCmd struct {
	FileID string `arg:"" name:"file-id" help:"File ID or path"`
	Fields string `help:"Fields to return" name:"fields"`
}

type FilesUploadCmd struct {
	LocalPath string `arg:"" name:"local-path" help:"Local file path"`
	Parent    string `help:"Parent folder ID" name:"parent"`
	Name      string `help:"File name" name:"name"`
	MimeType  string `help:"MIME type" name:"mime-type"`
}

type FilesDownloadCmd struct {
	FileID     string `arg:"" name:"file-id" help:"File ID or path"`
	OutputPath string `help:"Output path" name:"file-output"`
	MimeType   string `help:"Export MIME type" name:"mime-type"`
	Doc        bool   `help:"Export Google Docs as plain text" name:"doc" aliases:"doc-text"`
}

type FilesDeleteCmd struct {
	FileID           string `arg:"" name:"file-id" help:"File ID or path"`
	Permanent        bool   `help:"Permanently delete" name:"permanent"`
	SkipConfirmation bool   `help:"Skip confirmation" name:"skip-confirmation"`
}

type FilesCopyCmd struct {
	FileID string `arg:"" name:"file-id" help:"File ID or path"`
	Name   string `help:"New file name" name:"name"`
	Parent string `help:"Destination folder ID" name:"parent"`
}

type FilesMoveCmd struct {
	FileID string `arg:"" name:"file-id" help:"File ID or path"`
	Parent string `help:"New parent folder ID" name:"parent" required:""`
}

type FilesTrashCmd struct {
	FileID string `arg:"" name:"file-id" help:"File ID or path"`
}

type FilesRestoreCmd struct {
	FileID string `arg:"" name:"file-id" help:"File ID or path"`
}

type FilesRevisionsCmd struct {
	List     FilesRevisionsListCmd     `cmd:"" default:"withargs" help:"List file revisions"`
	Download FilesRevisionsDownloadCmd `cmd:"" help:"Download a specific revision"`
	Restore  FilesRevisionsRestoreCmd  `cmd:"" help:"Restore file to a specific revision"`
}

type FilesRevisionsListCmd struct {
	FileID string `arg:"" name:"file-id" help:"File ID or path"`
}

type FilesRevisionsDownloadCmd struct {
	FileID     string `arg:"" name:"file-id" help:"File ID or path"`
	RevisionID string `arg:"" name:"revision-id" help:"Revision ID"`
	OutputPath string `help:"Output path for revision download" name:"revision-output" required:""`
}

type FilesRevisionsRestoreCmd struct {
	FileID     string `arg:"" name:"file-id" help:"File ID or path"`
	RevisionID string `arg:"" name:"revision-id" help:"Revision ID"`
}

type FilesListTrashedCmd struct {
	Query     string `help:"Search query" name:"query"`
	Limit     int    `help:"Maximum files to return per page" default:"100" name:"limit"`
	PageToken string `help:"Page token for pagination" name:"page-token"`
	OrderBy   string `help:"Sort order" name:"order-by"`
	Fields    string `help:"Fields to return" name:"fields"`
	Paginate  bool   `help:"Automatically fetch all pages" name:"paginate"`
}

type FilesExportFormatsCmd struct {
	FileID string `arg:"" name:"file-id" help:"File ID or path"`
}

func getFileManager(ctx context.Context, flags types.GlobalFlags) (*files.Manager, *api.Client, *types.RequestContext, *OutputWriter, error) {
	out := NewOutputWriter(flags.OutputFormat, flags.Quiet, flags.Verbose)
	configDir := getConfigDir()
	authMgr := auth.NewManager(configDir)

	creds, err := authMgr.GetValidCredentials(ctx, flags.Profile)
	if err != nil {
		return nil, nil, nil, out, err
	}

	service, err := authMgr.GetDriveService(ctx, creds)
	if err != nil {
		return nil, nil, nil, out, err
	}

	client := api.NewClient(service, utils.DefaultMaxRetries, utils.DefaultRetryDelayMs, GetLogger())
	mgr := files.NewManager(client)
	reqCtx := api.NewRequestContext(flags.Profile, flags.DriveID, types.RequestTypeListOrSearch)

	return mgr, client, reqCtx, out, nil
}

func (cmd *FilesListCmd) Run(globals *Globals) error {
	flags := globals.ToGlobalFlags()
	ctx := context.Background()

	mgr, client, reqCtx, out, err := getFileManager(ctx, flags)
	if err != nil {
		return out.WriteError("files.list", utils.NewCLIError(utils.ErrCodeAuthRequired, err.Error()).Build())
	}

	// Resolve parent path if provided
	parentID := cmd.Parent
	if parentID != "" {
		resolvedID, err := ResolveFileID(ctx, client, flags, parentID)
		if err != nil {
			if appErr, ok := err.(*utils.AppError); ok {
				return out.WriteError("files.list", appErr.CLIError)
			}
			return out.WriteError("files.list", utils.NewCLIError(utils.ErrCodeInvalidPath, err.Error()).Build())
		}
		parentID = resolvedID
	}

	opts := files.ListOptions{
		ParentID:       parentID,
		Query:          cmd.Query,
		PageSize:       cmd.Limit,
		PageToken:      cmd.PageToken,
		OrderBy:        cmd.OrderBy,
		IncludeTrashed: cmd.IncludeTrashed,
		Fields:         cmd.Fields,
	}

	// If --paginate flag is set, fetch all pages
	if cmd.Paginate {
		allFiles, err := mgr.ListAll(ctx, reqCtx, opts)
		if err != nil {
			return handleCLIError(out, "files.list", err)
		}
		// Return result without nextPageToken (all pages fetched)
		return out.WriteSuccess("files.list", map[string]interface{}{
			"files": allFiles,
		})
	}

	result, err := mgr.List(ctx, reqCtx, opts)
	if err != nil {
		return handleCLIError(out, "files.list", err)
	}

	return out.WriteSuccess("files.list", result)
}

func (cmd *FilesGetCmd) Run(globals *Globals) error {
	flags := globals.ToGlobalFlags()
	ctx := context.Background()

	mgr, client, reqCtx, out, err := getFileManager(ctx, flags)
	if err != nil {
		return out.WriteError("files.get", utils.NewCLIError(utils.ErrCodeAuthRequired, err.Error()).Build())
	}

	// Resolve file ID from path if needed
	fileID, err := ResolveFileID(ctx, client, flags, cmd.FileID)
	if err != nil {
		if appErr, ok := err.(*utils.AppError); ok {
			return out.WriteError("files.get", appErr.CLIError)
		}
		return out.WriteError("files.get", utils.NewCLIError(utils.ErrCodeInvalidPath, err.Error()).Build())
	}

	reqCtx.RequestType = types.RequestTypeGetByID
	file, err := mgr.Get(ctx, reqCtx, fileID, cmd.Fields)
	if err != nil {
		return handleCLIError(out, "files.get", err)
	}

	return out.WriteSuccess("files.get", file)
}

func (cmd *FilesUploadCmd) Run(globals *Globals) error {
	flags := globals.ToGlobalFlags()
	ctx := context.Background()

	mgr, client, reqCtx, out, err := getFileManager(ctx, flags)
	if err != nil {
		return out.WriteError("files.upload", utils.NewCLIError(utils.ErrCodeAuthRequired, err.Error()).Build())
	}

	// Resolve parent path if provided
	parentID := cmd.Parent
	if parentID != "" {
		resolvedID, err := ResolveFileID(ctx, client, flags, parentID)
		if err != nil {
			if appErr, ok := err.(*utils.AppError); ok {
				return out.WriteError("files.upload", appErr.CLIError)
			}
			return out.WriteError("files.upload", utils.NewCLIError(utils.ErrCodeInvalidPath, err.Error()).Build())
		}
		parentID = resolvedID
	}

	reqCtx.RequestType = types.RequestTypeMutation
	file, err := mgr.Upload(ctx, reqCtx, cmd.LocalPath, files.UploadOptions{
		ParentID: parentID,
		Name:     cmd.Name,
		MimeType: cmd.MimeType,
		Quiet:    flags.Quiet,
	})
	if err != nil {
		return handleCLIError(out, "files.upload", err)
	}

	out.Log("Uploaded: %s", file.Name)
	return out.WriteSuccess("files.upload", file)
}

func (cmd *FilesDownloadCmd) Run(globals *Globals) error {
	flags := globals.ToGlobalFlags()
	ctx := context.Background()

	mgr, client, reqCtx, out, err := getFileManager(ctx, flags)
	if err != nil {
		return out.WriteError("files.download", utils.NewCLIError(utils.ErrCodeAuthRequired, err.Error()).Build())
	}

	// Resolve file ID from path if needed
	fileID, err := ResolveFileID(ctx, client, flags, cmd.FileID)
	if err != nil {
		if appErr, ok := err.(*utils.AppError); ok {
			return out.WriteError("files.download", appErr.CLIError)
		}
		return out.WriteError("files.download", utils.NewCLIError(utils.ErrCodeInvalidPath, err.Error()).Build())
	}

	reqCtx.RequestType = types.RequestTypeDownloadOrExport
	mimeType := cmd.MimeType
	if cmd.Doc && mimeType == "" {
		mimeType = "text/plain"
	}

	err = mgr.Download(ctx, reqCtx, fileID, files.DownloadOptions{
		OutputPath: cmd.OutputPath,
		MimeType:   mimeType,
	})
	if err != nil {
		return handleCLIError(out, "files.download", err)
	}

	out.Log("Downloaded to: %s", cmd.OutputPath)
	return out.WriteSuccess("files.download", map[string]string{"path": cmd.OutputPath})
}

func (cmd *FilesDeleteCmd) Run(globals *Globals) error {
	flags := globals.ToGlobalFlags()
	ctx := context.Background()

	mgr, client, reqCtx, out, err := getFileManager(ctx, flags)
	if err != nil {
		return out.WriteError("files.delete", utils.NewCLIError(utils.ErrCodeAuthRequired, err.Error()).Build())
	}

	// Resolve file ID from path if needed
	fileID, err := ResolveFileID(ctx, client, flags, cmd.FileID)
	if err != nil {
		if appErr, ok := err.(*utils.AppError); ok {
			return out.WriteError("files.delete", appErr.CLIError)
		}
		return out.WriteError("files.delete", utils.NewCLIError(utils.ErrCodeInvalidPath, err.Error()).Build())
	}

	reqCtx.RequestType = types.RequestTypeMutation
	err = mgr.Delete(ctx, reqCtx, fileID, cmd.Permanent)
	if err != nil {
		return handleCLIError(out, "files.delete", err)
	}

	action := "trashed"
	if cmd.Permanent {
		action = "deleted"
	}
	out.Log("File %s: %s", action, fileID)
	return out.WriteSuccess("files.delete", map[string]string{"id": fileID, "status": action})
}

func (cmd *FilesCopyCmd) Run(globals *Globals) error {
	flags := globals.ToGlobalFlags()
	ctx := context.Background()

	mgr, client, reqCtx, out, err := getFileManager(ctx, flags)
	if err != nil {
		return out.WriteError("files.copy", utils.NewCLIError(utils.ErrCodeAuthRequired, err.Error()).Build())
	}

	// Resolve file ID from path if needed
	fileID, err := ResolveFileID(ctx, client, flags, cmd.FileID)
	if err != nil {
		if appErr, ok := err.(*utils.AppError); ok {
			return out.WriteError("files.copy", appErr.CLIError)
		}
		return out.WriteError("files.copy", utils.NewCLIError(utils.ErrCodeInvalidPath, err.Error()).Build())
	}

	// Resolve parent path if provided
	parentID := cmd.Parent
	if parentID != "" {
		resolvedID, err := ResolveFileID(ctx, client, flags, parentID)
		if err != nil {
			if appErr, ok := err.(*utils.AppError); ok {
				return out.WriteError("files.copy", appErr.CLIError)
			}
			return out.WriteError("files.copy", utils.NewCLIError(utils.ErrCodeInvalidPath, err.Error()).Build())
		}
		parentID = resolvedID
	}

	reqCtx.RequestType = types.RequestTypeMutation
	file, err := mgr.Copy(ctx, reqCtx, fileID, cmd.Name, parentID)
	if err != nil {
		return handleCLIError(out, "files.copy", err)
	}

	out.Log("Copied to: %s", file.Name)
	return out.WriteSuccess("files.copy", file)
}

func (cmd *FilesMoveCmd) Run(globals *Globals) error {
	flags := globals.ToGlobalFlags()
	ctx := context.Background()

	mgr, client, reqCtx, out, err := getFileManager(ctx, flags)
	if err != nil {
		return out.WriteError("files.move", utils.NewCLIError(utils.ErrCodeAuthRequired, err.Error()).Build())
	}

	// Resolve file ID from path if needed
	fileID, err := ResolveFileID(ctx, client, flags, cmd.FileID)
	if err != nil {
		if appErr, ok := err.(*utils.AppError); ok {
			return out.WriteError("files.move", appErr.CLIError)
		}
		return out.WriteError("files.move", utils.NewCLIError(utils.ErrCodeInvalidPath, err.Error()).Build())
	}

	// Resolve parent path
	parentID, err := ResolveFileID(ctx, client, flags, cmd.Parent)
	if err != nil {
		if appErr, ok := err.(*utils.AppError); ok {
			return out.WriteError("files.move", appErr.CLIError)
		}
		return out.WriteError("files.move", utils.NewCLIError(utils.ErrCodeInvalidPath, err.Error()).Build())
	}

	reqCtx.RequestType = types.RequestTypeMutation
	file, err := mgr.Move(ctx, reqCtx, fileID, parentID)
	if err != nil {
		return handleCLIError(out, "files.move", err)
	}

	out.Log("Moved: %s", file.Name)
	return out.WriteSuccess("files.move", file)
}

func (cmd *FilesTrashCmd) Run(globals *Globals) error {
	flags := globals.ToGlobalFlags()
	ctx := context.Background()

	mgr, client, reqCtx, out, err := getFileManager(ctx, flags)
	if err != nil {
		return out.WriteError("files.trash", utils.NewCLIError(utils.ErrCodeAuthRequired, err.Error()).Build())
	}

	// Resolve file ID from path if needed
	fileID, err := ResolveFileID(ctx, client, flags, cmd.FileID)
	if err != nil {
		if appErr, ok := err.(*utils.AppError); ok {
			return out.WriteError("files.trash", appErr.CLIError)
		}
		return out.WriteError("files.trash", utils.NewCLIError(utils.ErrCodeInvalidPath, err.Error()).Build())
	}

	reqCtx.RequestType = types.RequestTypeMutation
	file, err := mgr.Trash(ctx, reqCtx, fileID)
	if err != nil {
		return handleCLIError(out, "files.trash", err)
	}

	out.Log("Trashed: %s", file.Name)
	return out.WriteSuccess("files.trash", file)
}

func (cmd *FilesRestoreCmd) Run(globals *Globals) error {
	flags := globals.ToGlobalFlags()
	ctx := context.Background()

	mgr, client, reqCtx, out, err := getFileManager(ctx, flags)
	if err != nil {
		return out.WriteError("files.restore", utils.NewCLIError(utils.ErrCodeAuthRequired, err.Error()).Build())
	}

	// Resolve file ID from path if needed
	fileID, err := ResolveFileID(ctx, client, flags, cmd.FileID)
	if err != nil {
		if appErr, ok := err.(*utils.AppError); ok {
			return out.WriteError("files.restore", appErr.CLIError)
		}
		return out.WriteError("files.restore", utils.NewCLIError(utils.ErrCodeInvalidPath, err.Error()).Build())
	}

	reqCtx.RequestType = types.RequestTypeMutation
	file, err := mgr.Restore(ctx, reqCtx, fileID)
	if err != nil {
		return handleCLIError(out, "files.restore", err)
	}

	out.Log("Restored: %s", file.Name)
	return out.WriteSuccess("files.restore", file)
}

func (cmd *FilesRevisionsListCmd) Run(globals *Globals) error {
	flags := globals.ToGlobalFlags()
	ctx := context.Background()

	_, client, reqCtx, out, err := getFileManager(ctx, flags)
	if err != nil {
		return out.WriteError("files.revisions", utils.NewCLIError(utils.ErrCodeAuthRequired, err.Error()).Build())
	}

	// Resolve file ID from path if needed
	fileID, err := ResolveFileID(ctx, client, flags, cmd.FileID)
	if err != nil {
		if appErr, ok := err.(*utils.AppError); ok {
			return out.WriteError("files.revisions", appErr.CLIError)
		}
		return out.WriteError("files.revisions", utils.NewCLIError(utils.ErrCodeInvalidPath, err.Error()).Build())
	}

	// Create revisions manager
	revMgr := revisions.NewManager(client)
	reqCtx.RequestType = types.RequestTypeListOrSearch

	result, err := revMgr.List(ctx, reqCtx, fileID, revisions.ListOptions{})
	if err != nil {
		return handleCLIError(out, "files.revisions", err)
	}

	return out.WriteSuccess("files.revisions", result)
}

func (cmd *FilesRevisionsDownloadCmd) Run(globals *Globals) error {
	flags := globals.ToGlobalFlags()
	ctx := context.Background()

	_, client, reqCtx, out, err := getFileManager(ctx, flags)
	if err != nil {
		return out.WriteError("files.revisions.download", utils.NewCLIError(utils.ErrCodeAuthRequired, err.Error()).Build())
	}

	// Resolve file ID from path if needed
	fileID, err := ResolveFileID(ctx, client, flags, cmd.FileID)
	if err != nil {
		if appErr, ok := err.(*utils.AppError); ok {
			return out.WriteError("files.revisions.download", appErr.CLIError)
		}
		return out.WriteError("files.revisions.download", utils.NewCLIError(utils.ErrCodeInvalidPath, err.Error()).Build())
	}

	revisionID := cmd.RevisionID

	// Create revisions manager
	revMgr := revisions.NewManager(client)
	reqCtx.RequestType = types.RequestTypeDownloadOrExport

	err = revMgr.Download(ctx, reqCtx, fileID, revisionID, revisions.DownloadOptions{
		OutputPath: cmd.OutputPath,
	})
	if err != nil {
		return handleCLIError(out, "files.revisions.download", err)
	}

	out.Log("Downloaded revision %s to: %s", revisionID, cmd.OutputPath)
	return out.WriteSuccess("files.revisions.download", map[string]string{"revisionId": revisionID, "path": cmd.OutputPath})
}

func (cmd *FilesRevisionsRestoreCmd) Run(globals *Globals) error {
	flags := globals.ToGlobalFlags()
	ctx := context.Background()

	_, client, reqCtx, out, err := getFileManager(ctx, flags)
	if err != nil {
		return out.WriteError("files.revisions.restore", utils.NewCLIError(utils.ErrCodeAuthRequired, err.Error()).Build())
	}

	// Resolve file ID from path if needed
	fileID, err := ResolveFileID(ctx, client, flags, cmd.FileID)
	if err != nil {
		if appErr, ok := err.(*utils.AppError); ok {
			return out.WriteError("files.revisions.restore", appErr.CLIError)
		}
		return out.WriteError("files.revisions.restore", utils.NewCLIError(utils.ErrCodeInvalidPath, err.Error()).Build())
	}

	revisionID := cmd.RevisionID

	// Create revisions manager
	revMgr := revisions.NewManager(client)
	reqCtx.RequestType = types.RequestTypeMutation

	file, err := revMgr.Restore(ctx, reqCtx, fileID, revisionID)
	if err != nil {
		return handleCLIError(out, "files.revisions.restore", err)
	}

	out.Log("Restored file to revision: %s", revisionID)
	return out.WriteSuccess("files.revisions.restore", file)
}

func (cmd *FilesListTrashedCmd) Run(globals *Globals) error {
	flags := globals.ToGlobalFlags()
	ctx := context.Background()

	mgr, _, reqCtx, out, err := getFileManager(ctx, flags)
	if err != nil {
		return out.WriteError("files.list-trashed", utils.NewCLIError(utils.ErrCodeAuthRequired, err.Error()).Build())
	}

	opts := files.ListOptions{
		Query:     cmd.Query,
		PageSize:  cmd.Limit,
		PageToken: cmd.PageToken,
		OrderBy:   cmd.OrderBy,
		Fields:    cmd.Fields,
	}

	// If --paginate flag is set, fetch all pages
	if cmd.Paginate {
		// Use ListAll with trashed query
		opts.IncludeTrashed = true
		if opts.Query != "" {
			opts.Query = "trashed = true and (" + opts.Query + ")"
		} else {
			opts.Query = "trashed = true"
		}
		allFiles, err := mgr.ListAll(ctx, reqCtx, opts)
		if err != nil {
			return handleCLIError(out, "files.list-trashed", err)
		}
		return out.WriteSuccess("files.list-trashed", map[string]interface{}{
			"files": allFiles,
		})
	}

	result, err := mgr.ListTrashed(ctx, reqCtx, opts)
	if err != nil {
		return handleCLIError(out, "files.list-trashed", err)
	}

	return out.WriteSuccess("files.list-trashed", result)
}

func (cmd *FilesExportFormatsCmd) Run(globals *Globals) error {
	flags := globals.ToGlobalFlags()
	ctx := context.Background()

	mgr, client, reqCtx, out, err := getFileManager(ctx, flags)
	if err != nil {
		return out.WriteError("files.export-formats", utils.NewCLIError(utils.ErrCodeAuthRequired, err.Error()).Build())
	}

	// Resolve file ID from path if needed
	fileID, err := ResolveFileID(ctx, client, flags, cmd.FileID)
	if err != nil {
		if appErr, ok := err.(*utils.AppError); ok {
			return out.WriteError("files.export-formats", appErr.CLIError)
		}
		return out.WriteError("files.export-formats", utils.NewCLIError(utils.ErrCodeInvalidPath, err.Error()).Build())
	}

	reqCtx.RequestType = types.RequestTypeGetByID
	file, err := mgr.Get(ctx, reqCtx, fileID, "mimeType,name")
	if err != nil {
		return handleCLIError(out, "files.export-formats", err)
	}

	formats, err := export.GetAvailableFormats(file.MimeType)
	if err != nil {
		return out.WriteError("files.export-formats", utils.NewCLIError(utils.ErrCodeUnknown, err.Error()).Build())
	}

	result := map[string]interface{}{
		"file": map[string]string{
			"id":       fileID,
			"name":     file.Name,
			"mimeType": file.MimeType,
		},
		"availableFormats": formats,
	}

	return out.WriteSuccess("files.export-formats", result)
}
